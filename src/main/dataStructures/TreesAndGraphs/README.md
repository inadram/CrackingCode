2.  Given a directed graph, design an algorithm to find out whether there is a route between two nodes.[ [two][102] ]
3.  Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a binary search tree with minimal height.[ [three][103] ]
4.  Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth (e.g., if you have a tree with depth D,you'll have D linked list). [ [four][104] ]
5.  implement a function to check if a binary tree is a binary search tree. [ [five][105] ] 
6.  Write an algorithm to find the 'next'node (i.e., in-order successor) of a given node in a binary search tree. You may assume that each node has a link to its parent.[ [six][106] ]
7.  Design an algorithm and write code to find the first common ancestor of two nodes ina binary tree. Avoid storing additional nodes in a data structure. NOTE:This is not necessarily a binary search tree. [ [seven][107] ]
8.  You have two very large binary trees: Tl, with millions of nodes, and T2, with hundreds of nodes.Create an algorithm to decide if T2 is a subtree of Tl. A tree T2 is a subtree of Tl if there exists a node n in Tl such that the subtree ofn is identical to T2. That is, if you cut off the tree at node n, the two trees would be identical.[ [eight][108] ]    
    
[102]:https://github.com/inadram/CrackingCode/tree/master/src/main/dataStructures/TreesAndGraphs/Two
[103]:https://github.com/inadram/CrackingCode/tree/master/src/main/dataStructures/TreesAndGraphs/Three
[104]:https://github.com/inadram/CrackingCode/tree/master/src/main/dataStructures/TreesAndGraphs/Four
[105]:https://github.com/inadram/CrackingCode/tree/master/src/main/dataStructures/TreesAndGraphs/Five
[106]:https://github.com/inadram/CrackingCode/tree/master/src/main/dataStructures/TreesAndGraphs/Six
[107]:https://github.com/inadram/CrackingCode/tree/master/src/main/dataStructures/TreesAndGraphs/Seven
[108]:https://github.com/inadram/CrackingCode/tree/master/src/main/dataStructures/TreesAndGraphs/Eight 
